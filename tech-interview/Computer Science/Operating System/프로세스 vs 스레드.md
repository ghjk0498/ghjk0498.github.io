# 프로세스와 스레드의 차이점

## ❓ 면접 질문
"프로세스(Process)와 스레드(Thread)의 차이점에 대해 설명해주세요."

## ✅ 핵심 답변

### 개념 정리
- **프로세스**: 실행 중인 프로그램의 인스턴스로, 독립적인 메모리 공간을 가지는 실행 단위
- **스레드**: 프로세스 내에서 실행되는 여러 실행 흐름의 단위로, 프로세스의 자원을 공유하는 경량 프로세스

### 상세 설명

#### 1. 메모리 구조의 차이
**프로세스**
- 독립적인 메모리 공간 보유 (Code, Data, Heap, Stack 영역)
- 다른 프로세스와 메모리 공간을 공유하지 않음
- 프로세스 간 통신은 IPC(Inter-Process Communication) 필요

**스레드**
- 같은 프로세스 내 스레드들이 Code, Data, Heap 영역 공유
- 각 스레드는 독립적인 Stack과 PC(Program Counter) 보유
- 메모리 공유로 인한 빠른 데이터 교환 가능

#### 2. 생성과 관리 비용
**프로세스**
- 생성 시 많은 자원과 시간이 필요 (무거운 단위)
- Context Switching 시 오버헤드가 큼
- 독립적이므로 한 프로세스 오류가 다른 프로세스에 영향 없음

**스레드**
- 생성과 전환이 빠름 (경량 단위)
- Context Switching 비용이 적음
- 한 스레드의 오류가 전체 프로세스에 영향을 줄 수 있음

#### 3. 통신 방식
**프로세스 간 통신**
- 파이프(Pipe), 메시지 큐(Message Queue), 공유 메모리(Shared Memory), 소켓(Socket) 등 사용
- 통신 방법이 복잡하고 비용이 큼

**스레드 간 통신**
- 전역 변수, 힙 메모리를 통한 직접적인 데이터 공유
- 단순하고 빠르지만 동기화 문제 발생 가능

### 면접 답변 템플릿
"프로세스와 스레드의 가장 큰 차이점은 **메모리 공유 여부**입니다. 

프로세스는 독립적인 메모리 공간을 가지고 있어서 안전하지만 생성 비용이 크고, 프로세스 간 통신을 위해서는 별도의 IPC 메커니즘이 필요합니다.

반면 스레드는 같은 프로세스 내에서 메모리를 공유하기 때문에 생성 비용이 적고 통신이 빠르지만, 하나의 스레드에서 문제가 발생하면 전체 프로세스에 영향을 줄 수 있습니다.

따라서 **독립성과 안정성이 중요하면 멀티프로세싱**, **성능과 자원 효율성이 중요하면 멀티스레딩**을 선택하는 것이 좋습니다."

## 📚 참고할만한 정보

### 심화 개념

#### Context Switching 비교
```text
프로세스 Context Switching:
1. 현재 프로세스 상태 저장 (레지스터, PC, 메모리 맵 등)
2. MMU(Memory Management Unit) 설정 변경
3. 캐시 메모리 무효화 (Cache Miss 발생)
4. 새 프로세스 상태 복원

스레드 Context Switching:
1. 레지스터와 PC만 저장/복원
2. 메모리 맵 유지 (같은 프로세스 내)
3. 캐시 메모리 대부분 유지
```

#### 메모리 레이아웃 비교
```text
프로세스 A               프로세스 B
┌─────────────┐         ┌─────────────┐
│    Stack    │         │    Stack    │
├─────────────┤         ├─────────────┤
│    Heap     │         │    Heap     │
├─────────────┤         ├─────────────┤
│    Data     │         │    Data     │
├─────────────┤         ├─────────────┤
│    Code     │         │    Code     │
└─────────────┘         └─────────────┘

하나의 프로세스 내 멀티스레드
┌───────────────┐
│ Thread1 Stack │
├───────────────┤
│ Thread2 Stack │
├───────────────┤
│ Thread3 Stack │
├───────────────┤
│ Shared Heap   │
├───────────────┤
│ Shared Data   │
├───────────────┤
│ Shared Code   │
└───────────────┘
```

### 실무 예시

#### 언제 멀티프로세싱을 사용할까?
- **웹 서버**: Apache의 prefork 모드 (안정성 중시)
- **브라우저**: Chrome의 탭별 프로세스 분리 (한 탭 크래시가 다른 탭에 영향 없음)
- **데이터베이스**: PostgreSQL의 프로세스 기반 아키텍처

#### 언제 멀티스레딩을 사용할까?
- **웹 서버**: Nginx, Apache worker 모드 (높은 동시성)
- **게임 엔진**: 렌더링, 물리 계산, AI를 각각 다른 스레드에서 처리
- **미디어 플레이어**: 디코딩, 렌더링, UI를 분리된 스레드에서 처리

### 관련 기술
- **동기화 메커니즘**: Mutex, Semaphore, Monitor
- **스레드 풀(Thread Pool)**: 스레드 생성/소멸 비용 최적화
- **비동기 프로그래밍**: async/await, Future/Promise 패턴
- **액터 모델**: Erlang, Akka에서 사용하는 동시성 모델

## 💡 면접 팁
- 단순히 정의만 외우지 말고 **왜 그런 차이가 생기는지** 논리적으로 설명
- **구체적인 예시**를 들어서 설명하면 이해도가 높다고 평가받음
- **트레이드오프 관점**에서 접근: "상황에 따라 선택이 달라진다"
- **메모리 관점**에서의 설명이 가장 핵심적이고 면접관들이 원하는 답변

## ⚠️ 주의사항
- "스레드가 무조건 빠르다"는 잘못된 일반화 피하기
- 동시성(Concurrency)과 병렬성(Parallelism) 개념 혼동하지 않기
- 플랫폼별 구현 차이 있음을 인지 (Linux의 clone(), Windows의 CreateThread())

## 🏷️ 태그
`운영체제` `프로세스` `스레드` `멀티프로세싱` `멀티스레딩` `Context-Switching` `메모리관리` `동시성`
