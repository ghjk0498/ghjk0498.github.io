# 액터 모델 (Actor Model)

## ❓ 면접 질문
"액터 모델(Actor Model)에 대해 설명하고, 기존의 스레드 기반 동시성 모델과 어떤 차이점이 있는지 설명해주세요."

## ✅ 핵심 답변

### 개념 정리
액터 모델은 병렬 및 분산 컴퓨팅을 위한 수학적 모델로, 모든 것을 '액터(Actor)'라는 독립적인 개체로 취급하여 동시성을 구현하는 프로그래밍 패러다임입니다.

### 상세 설명

**액터의 특징:**
- **독립성**: 각 액터는 자신만의 상태와 메일박스를 가짐
- **메시지 기반 통신**: 액터들은 오직 메시지를 통해서만 소통
- **비동기 처리**: 메시지 전송과 수신이 비동기적으로 이루어짐
- **캡슐화**: 액터의 내부 상태는 외부에서 직접 접근 불가

**액터가 할 수 있는 동작:**
1. 메시지 수신 및 처리
2. 다른 액터에게 메시지 전송
3. 새로운 액터 생성
4. 다음 메시지에 대한 행동 결정

**기존 스레드 모델과의 차이점:**

| 구분 | 스레드 모델 | 액터 모델 |
|------|-------------|-----------|
| 상태 공유 | 공유 메모리 사용 | 상태 격리, 메시지로만 통신 |
| 동기화 | Lock, Mutex 등 필요 | Lock-free, 메시지 큐 기반 |
| 오류 처리 | 전체 프로세스 영향 가능 | 액터 단위로 격리된 오류 처리 |
| 확장성 | 스레드 수 제한 | 수백만 개의 액터 생성 가능 |
| 복잡성 | 데드락, 레이스 컨디션 | 메시지 순서, 백프레셔 관리 |

### 면접 답변 템플릿
"액터 모델은 동시성 문제를 해결하기 위한 패러다임으로, 모든 계산 단위를 독립적인 액터로 모델링합니다. 

핵심 특징은 첫째, 각 액터가 독립적인 상태를 가지며 외부에서 직접 접근할 수 없다는 점입니다. 둘째, 액터들은 오직 비동기 메시지를 통해서만 소통합니다. 

기존 스레드 모델과 비교하면, 스레드는 공유 메모리를 사용하여 락이 필요하지만, 액터 모델은 상태를 격리시켜 락이 불필요합니다. 이로 인해 데드락이나 레이스 컨디션 같은 문제를 원천적으로 방지할 수 있습니다.

실제로 Erlang/Elixir, Akka(Scala/Java), Orleans(.NET) 등에서 이 모델을 활용하고 있습니다."

## 📚 참고할만한 정보

### 심화 개념

**메시지 전달 방식:**
```text
Actor A                    Actor B
  |                          |
  |-----> Message --------->|
  |                          |
  |<----- Response ---------|
  |                          |
```

**액터 계층 구조 (Actor Hierarchy):**
- 부모 액터가 자식 액터를 관리
- Supervisor Strategy로 오류 처리
- Let-it-crash 철학

**백프레셔(Backpressure) 처리:**
- 메시지 큐 오버플로우 방지
- Flow control 메커니즘
- Circuit breaker 패턴

### 실무 예시

**Akka를 사용한 간단한 액터 예시:**
```scala
import akka.actor.Actor

class GreetingActor extends Actor {
  def receive = {
    case "hello" => sender() ! "Hello back!"
    case "hi" => sender() ! "Hi there!"
    case _ => sender() ! "I don't understand"
  }
}
```

**Erlang/Elixir의 GenServer 예시:**
```elixir
defmodule Counter do
  use GenServer

  def start_link(initial_value) do
    GenServer.start_link(__MODULE__, initial_value)
  end

  def increment(pid) do
    GenServer.call(pid, :increment)
  end

  def handle_call(:increment, _from, state) do
    {:reply, state + 1, state + 1}
  end
end
```

### 관련 기술

**액터 모델을 지원하는 기술들:**
- **Erlang/Elixir**: BEAM VM에서 경량 프로세스로 구현
- **Akka**: JVM 기반 액터 시스템
- **Orleans**: Microsoft의 .NET 액터 프레임워크
- **CAF**: C++ Actor Framework
- **Pykka**: Python용 액터 라이브러리

**적용 분야:**
- 분산 시스템
- 실시간 시스템
- 게임 서버
- IoT 시스템
- 금융 거래 시스템

## 💡 면접 팁

**자주 나오는 꼬리 질문들:**
1. "액터 모델의 단점은 무엇인가요?"
   - 메시지 오버헤드, 디버깅의 어려움, 학습 곡선
2. "어떤 상황에서 액터 모델을 사용하시겠습니까?"
   - 높은 동시성, 분산 처리, 내결함성이 중요한 시스템
3. "액터 간 메시지 전달에서 순서는 보장되나요?"
   - 같은 송신자-수신자 쌍에서는 순서 보장, 전체적으로는 비보장

**강조할 포인트:**
- Lock-free 특성으로 인한 성능상 이점
- 내결함성과 격리된 오류 처리
- 수평 확장성의 우수함

## 🏷️ 태그
`#동시성` `#병렬처리` `#분산시스템` `#메시지패싱` `#액터모델` `#Akka` `#Erlang` `#비동기` `#내결함성`
