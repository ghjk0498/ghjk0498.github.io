# Bubble Sort

## 📌 핵심 요약
- 인접한 두 원소를 비교하여 크기 순으로 교환하는 단순한 정렬 알고리즘
- 마치 거품이 수면으로 올라오는 것처럼 큰 값이 배열 끝으로 이동하는 모습에서 이름 유래
- 구현이 쉽지만 시간복잡도가 O(n²)로 비효율적
- 알고리즘 학습의 기초이자 다른 정렬 알고리즘 이해의 출발점

## 🎯 주요 개념

### 기본 정의
배열의 첫 번째 원소부터 시작하여 인접한 두 원소를 비교하고, 순서가 잘못되어 있으면 위치를 바꾸는 과정을 반복하는 정렬 방법

### 핵심 원리
1. **인접 비교**: 바로 옆에 있는 두 원소끼리만 비교
2. **조건부 교환**: 정렬 순서에 맞지 않으면 위치 교환
3. **반복 수행**: 전체 배열이 정렬될 때까지 과정 반복

### 주요 특징
- **안정 정렬**: 같은 값을 가진 원소들의 상대적 순서 유지
- **제자리 정렬**: 추가 메모리 공간 거의 불필요
- **비교 기반**: 원소 간 크기 비교를 통한 정렬

## 📊 상세 내용

### 동작 과정
**1단계**: 첫 번째 원소부터 마지막까지 인접한 원소들을 순차적으로 비교
- 앞의 원소가 뒤의 원소보다 크면 위치 교환
- 한 번의 순회로 가장 큰 원소가 마지막 위치에 확정

**2단계**: 마지막 원소를 제외하고 처음부터 다시 비교 시작
- 두 번째로 큰 원소가 끝에서 두 번째 위치에 확정

**3단계**: 정렬이 완료될 때까지 반복

### 성능 분석
- **시간복잡도**: 
  - 최악의 경우: O(n²) - 역순으로 정렬된 경우
  - 최선의 경우: O(n) - 이미 정렬된 경우 (최적화 버전)
  - 평균: O(n²)
- **공간복잡도**: O(1) - 상수 공간만 사용

### 구현 핵심
```
반복 횟수: n-1번의 패스
각 패스에서: 점점 줄어드는 비교 횟수
교환 조건: arr[i] > arr[i+1] (오름차순 기준)
```

## 💡 실제 활용

### 적용 사례
- **교육 목적**: 정렬 알고리즘 개념 설명
- **소규모 데이터**: 원소 개수가 매우 적은 경우
- **부분 정렬**: 몇 개의 큰 값만 뒤로 보내고 싶을 때

### 장단점 분석

**장점**:
- 구현이 매우 간단하고 직관적
- 추가 메모리 공간이 거의 불필요
- 안정 정렬로 동일한 값의 순서 보장
- 정렬 과정을 시각화하기 쉬움

**단점**:
- 시간복잡도가 O(n²)로 비효율적
- 큰 데이터셋에서는 실용성 부족
- 데이터 이동 횟수가 많음
- 현실적인 성능상 다른 알고리즘에 비해 열등

### 최적화 방법
> 💡 **개선 팁**: 한 번의 패스에서 교환이 일어나지 않으면 정렬 완료로 판단하여 조기 종료

## 🔗 관련 주제

### 선행 지식
- [배열과 리스트](./배열구조.md) - 기본 자료구조 이해 필요
- [비교 연산](./비교연산.md) - 원소 간 크기 비교 개념

### 연관 개념
- [선택 정렬](./선택정렬.md) - 비슷한 시간복잡도의 단순 정렬
- [삽입 정렬](./삽입정렬.md) - 개선된 단순 정렬 알고리즘
- [안정 정렬](./안정정렬.md) - 정렬의 안정성 개념

### 심화 학습 경로
- [퀵 정렬](./퀵정렬.md) - 분할정복 기반 효율적 정렬
- [머지 정렬](./머지정렬.md) - 안정적이고 효율적인 정렬
- [정렬 알고리즘 비교](./정렬비교.md) - 다양한 정렬 방법 성능 분석

## 📚 참고 자료

### 시각적 학습
- 정렬 과정 애니메이션으로 동작 원리 이해
- 다른 정렬 알고리즘과의 성능 비교 차트

### 실습 권장
- 직접 손으로 카드나 숫자를 정렬해보기
- 단계별 동작 과정 추적 연습

> ⚠️ **주의사항**: 실무에서는 성능상 거의 사용되지 않으므로, 개념 이해와 다른 알고리즘 학습을 위한 기초로 활용

> 📌 **기억할 점**: 버블 정렬은 알고리즘의 기초 개념을 이해하는 출발점이지, 실제 프로젝트에서 사용할 정렬 방법은 아님

## 🏷️ 태그
#정렬알고리즘 #기초개념 #교육용 #O(n²) #안정정렬 #제자리정렬
